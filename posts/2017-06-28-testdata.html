<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>enter_haken - providing test data for databases</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-109218061-1"></script>
        <script>
          var gaProperty = 'UA-109218061-1';
          var disableString = 'ga-disable-' + gaProperty;
       
          if (document.cookie.indexOf(disableString + '=true') > -1) {
              window[disableString] = true;
          }
 
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', gaProperty, { 'anonymize_ip' : true });
        </script>
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../">enter_haken</a>
                <a href="../projects.html">projects</a>
                <a href="../cookbook.html">cookbook</a>
                <a href="../notes.html">notes</a>
                <a href="../read.html">read</a>
                <a href="../about.html">about</a>
            </div>
        </div>

        <div id="content">
            <h1>providing test data for databases</h1>

<div class="info">
    
    Posted on June 28, 2017
    
        
</div>

<p>A few days ago, I did some experiments with PostgreSQL JSONB columns. A used a simple person model for my tests, containing address data for a person.</p>
<p>For my tests, I needed some test data. I could have generated some random strings, but I wanted to fill the database with more realistic data. I have often thought of a test data generator for commonly used data models. If you want to generate randomized addresses for a person, you need a big list of street names and city names. When it comes to geographical data like this, <a href="https://www.openstreetmap.org">open street maps</a> comes into the game.</p>
<!--more-->
<p>Because I live in North rhine westphalia, I use <a href="http://download.geofabrik.de/europe/germany/nordrhein-westfalen.html">local data</a> from the German <a href="https://www.openstreetmap.org">open street map</a> provider <a href="http://www.geofabrik.de/">geofabrik</a>. At the time of writing the pbf data is about 647 MB in size. This file contains all cities, highways, residential data, rail ways and so on. I only need a fraction of this. The osm community has build a tool called <a href="http://wiki.openstreetmap.org/wiki/Osmosis">osmosis</a> for this. With osmosis you can filter the data and save the result in a XML file.</p>
<h1 id="cities">Cities</h1>
<pre><code>$ osmosis --read-pbf nordrhein-westfalen-latest.osm.pbf \
&gt; --tf accept-nodes place=city,town,village,hamlet,suburb \
&gt; --tf reject-relations \
&gt; --tf reject-ways \
&gt; --write-xml nrw-cities.osm
Jun 28, 2017 07:44:09 PM org.openstreetmap.osmosis.core.Osmosis run
INFORMATION: Osmosis Version 0.40.1
Jun 28, 2017 07:44:09 PM org.openstreetmap.osmosis.core.Osmosis run
INFORMATION: Preparing pipeline.
Jun 28, 2017 07:44:09 PM org.openstreetmap.osmosis.core.Osmosis run
INFORMATION: Launching pipeline execution.
Jun 28, 2017 07:44:09 PM org.openstreetmap.osmosis.core.Osmosis run
INFORMATION: Pipeline executing, waiting for completion.
Jun 28, 2017 07:44:53 PM org.openstreetmap.osmosis.core.Osmosis run
INFORMATION: Pipeline complete.
Jun 28, 2017 07:44:53 PM org.openstreetmap.osmosis.core.Osmosis run
INFORMATION: Total execution time: 44140 milliseconds.</code></pre>
<p>As a result, you get a 3MB xml file. The file contains all nodes with a <a href="http://wiki.openstreetmap.org/wiki/Key:place">place tag</a>, containing either <code>city</code>, <code>town</code>, <code>village</code>, <code>hamlet</code> or <code>suburb</code>. These tags has usually have a <a href="http://wiki.openstreetmap.org/wiki/Key:name">name tag</a>.</p>
<p>The city Dortmund looks like</p>
<pre><code>&lt;node id=&quot;25293125&quot; version=&quot;33&quot; timestamp=&quot;2017-05-08T12:12:08Z&quot; uid=&quot;5706452&quot; user=&quot;Bienson&quot; changeset=&quot;48500235&quot; lat=&quot;51.5142273&quot; lon=&quot;7.4652789&quot;&gt;
  &lt;tag k=&quot;ele&quot; v=&quot;86&quot;/&gt;
  &lt;tag k=&quot;is_in&quot; v=&quot;Regierungsbezirk Arnsberg,Nordrhein-Westfalen,Bundesrepublik Deutschland,Europe&quot;/&gt;
  &lt;tag k=&quot;is_in:country_code&quot; v=&quot;DE&quot;/&gt;
  &lt;tag k=&quot;is_in:iso_3166_2&quot; v=&quot;DE-NW&quot;/&gt;
  &lt;tag k=&quot;name&quot; v=&quot;Dortmund&quot;/&gt;
  &lt;tag k=&quot;name:de&quot; v=&quot;Dortmund&quot;/&gt;
  &lt;tag k=&quot;name:hu&quot; v=&quot;Dortmund&quot;/&gt;
  ...
  &lt;tag k=&quot;openGeoDB:community_identification_number&quot; v=&quot;05913&quot;/&gt;
  &lt;tag k=&quot;openGeoDB:is_in_loc_id&quot; v=&quot;179&quot;/&gt;
  &lt;tag k=&quot;openGeoDB:layer&quot; v=&quot;5&quot;/&gt;
  &lt;tag k=&quot;openGeoDB:license_plate_code&quot; v=&quot;DO&quot;/&gt;
  &lt;tag k=&quot;openGeoDB:loc_id&quot; v=&quot;404&quot;/&gt;
  &lt;tag k=&quot;place&quot; v=&quot;city&quot;/&gt;
  &lt;tag k=&quot;place:importance&quot; v=&quot;2&quot;/&gt;
  &lt;tag k=&quot;population&quot; v=&quot;600933&quot;/&gt;
  &lt;tag k=&quot;ref:LOCODE&quot; v=&quot;DEDTM&quot;/&gt;
  &lt;tag k=&quot;website&quot; v=&quot;http://www.dortmund.de&quot;/&gt;
  &lt;tag k=&quot;wikidata&quot; v=&quot;Q1295&quot;/&gt;
  &lt;tag k=&quot;wikipedia&quot; v=&quot;de:Dortmund&quot;/&gt;
&lt;/node&gt;</code></pre>
<p>At this point you can decide either to use a xml library for extracting the name tag, or to use the Linux system tools. I start over with the system tools. Let’s look how far we can get.</p>
<p>A first <code>grep</code> gets every line with a name tag.</p>
<pre><code>$ grep 'k=&quot;name&quot;' nrw-cities.osm | head
    &lt;tag k=&quot;name&quot; v=&quot;Dingden&quot;/&gt;
    &lt;tag k=&quot;name&quot; v=&quot;Bocholt&quot;/&gt;
    &lt;tag k=&quot;name&quot; v=&quot;Köln&quot;/&gt;
    &lt;tag k=&quot;name&quot; v=&quot;Herne&quot;/&gt;
    &lt;tag k=&quot;name&quot; v=&quot;Lünen&quot;/&gt;
    &lt;tag k=&quot;name&quot; v=&quot;Alstedde&quot;/&gt;
    &lt;tag k=&quot;name&quot; v=&quot;Heggen&quot;/&gt;
    &lt;tag k=&quot;name&quot; v=&quot;Herzebrock-Clarholz&quot;/&gt;
    &lt;tag k=&quot;name&quot; v=&quot;Dortmund&quot;/&gt;
    &lt;tag k=&quot;name&quot; v=&quot;Schlangen&quot;/&gt;</code></pre>
<p>Looks promising. With a <code>cut</code> I can extract the values of the tag.</p>
<pre><code>$ grep 'k=&quot;name&quot;' nrw-cities.osm | cut -d\&quot; -f4 | head
Dingden
Bocholt
Köln
Herne
Lünen
Alstedde
Heggen
Herzebrock-Clarholz
Dortmund
Schlangen</code></pre>
<p>At this point, you can get a unique sorted list with</p>
<pre><code>$ grep 'k=&quot;name&quot;' nrw-cities.osm | cut -d\&quot; -f4 | sort | uniq | head
Aachen
Aan de Popelaar
Aandeschool
Aarmühle
Aaseestadt
Abbenroth
Abenden
Abstoß
Abtsküche
Achterberg</code></pre>
<p>As a result we have</p>
<pre><code>$ grep 'k=&quot;name&quot;' nrw-cities.osm | cut -d\&quot; -f4 | sort | uniq | wc -l
7725</code></pre>
<p>unique elements.</p>
<h1 id="streets">Streets</h1>
<pre><code>$ osmosis --read-pbf nordrhein-westfalen-latest.osm.pbf \
&gt; --wkv keyValueList=highway.residential \
&gt; --tf reject-nodes \
&gt; --tf reject-relations \
&gt; --write-xml nrw-streets.osm
Jun 28, 2017 08:34:04 PM org.openstreetmap.osmosis.core.Osmosis run
INFORMATION: Osmosis Version 0.40.1
Jun 28, 2017 08:34:04 PM org.openstreetmap.osmosis.core.Osmosis run
INFORMATION: Preparing pipeline.
Jun 28, 2017 08:34:04 PM org.openstreetmap.osmosis.core.Osmosis run
INFORMATION: Launching pipeline execution.
Jun 28, 2017 08:34:04 PM org.openstreetmap.osmosis.core.Osmosis run
INFORMATION: Pipeline executing, waiting for completion.
Jun 28, 2017 08:35:11 PM org.openstreetmap.osmosis.core.Osmosis run
INFORMATION: Pipeline complete.
Jun 28, 2017 08:35:11 PM org.openstreetmap.osmosis.core.Osmosis run
INFORMATION: Total execution time: 66564 milliseconds.</code></pre>
<p>This result contains only <a href="http://wiki.openstreetmap.org/wiki/Way">way xml nodes</a> containing a <a href="http://wiki.openstreetmap.org/wiki/Key:highway">highway tag</a> with the value <code>residential</code>.</p>
<pre><code>&lt;way id=&quot;455771&quot; version=&quot;15&quot; timestamp=&quot;2017-03-09T07:41:37Z&quot; uid=&quot;67862&quot; user=&quot;HolgerJeromin&quot; changeset=&quot;46719636&quot;&gt;
  &lt;nd ref=&quot;290215666&quot;/&gt;
  &lt;nd ref=&quot;2704621&quot;/&gt;
  &lt;nd ref=&quot;1256434820&quot;/&gt;
  &lt;nd ref=&quot;1834309845&quot;/&gt;
  &lt;nd ref=&quot;2896578753&quot;/&gt;
  &lt;nd ref=&quot;2704622&quot;/&gt;
  &lt;nd ref=&quot;2704623&quot;/&gt;
  &lt;tag k=&quot;highway&quot; v=&quot;living_street&quot;/&gt;
  &lt;tag k=&quot;lit&quot; v=&quot;yes&quot;/&gt;
  &lt;tag k=&quot;name&quot; v=&quot;Ernst-Meurin-Straße&quot;/&gt;
  &lt;tag k=&quot;surface&quot; v=&quot;paving_stones&quot;/&gt;
&lt;/way&gt;    </code></pre>
<p>Ways with a name tag are usually urban ways. All other ways will be filtered.</p>
<p>The names can be extracted on the same way, like it is done with the cities.</p>
<pre><code>$ grep 'k=&quot;name&quot;' nrw-streets.osm | cut -d\&quot; -f4 | sort | uniq | head
55er Straße
(A7)
Aabach Aue
Aabauerschaft
Aachener Ende
Aachener Glacis
Aachener Gracht
Aachener Platz
Aachener Straße
Aachener Weg</code></pre>
<p>The North rhine westphalia file contains</p>
<pre><code>$ grep 'k=&quot;name&quot;' nrw-streets.osm | cut -d\&quot; -f4 | sort | uniq | wc -l
71787</code></pre>
<p>unique streets.</p>
<p>If you want to know, how often a street name is used in North rhine westphalia, you can extend the query like</p>
<pre><code>$ grep 'k=&quot;name&quot;' nrw-streets.osm | cut -d\&quot; -f4 | sort | uniq -c | sort -rn | head -n 20
    749 Bahnhofstraße
    651 Schulstraße
    640 Gartenstraße
    618 Bergstraße
    574 Kirchstraße
    493 Bachstraße
    478 Ringstraße
    473 Mühlenstraße
    457 Schillerstraße
    434 Dorfstraße
    428 Breslauer Straße
    408 Goethestraße
    402 Jahnstraße
    400 Lindenstraße
    397 Feldstraße
    394 Hauptstraße
    374 Wiesenstraße
    372 Mühlenweg
    368 Schützenstraße
    359 Waldstraße</code></pre>
<p>This can be useful, if you like to use the top <code>n</code> street names of the whole list.</p>
<pre><code>$ grep 'k=&quot;name&quot;' nrw-streets.osm | cut -d\&quot; -f4 | sort | uniq -c | sort -rn | \
&gt; head -n 20 | sed -e 's/^[[:space:]]*//' | cut -d' ' -f2-
Bahnhofstraße
Schulstraße
Gartenstraße
Bergstraße
Kirchstraße
Bachstraße
Ringstraße
Mühlenstraße
Schillerstraße
Dorfstraße
Breslauer Straße
Goethestraße
Jahnstraße
Lindenstraße
Feldstraße
Hauptstraße
Wiesenstraße
Mühlenweg
Schützenstraße
Waldstraße</code></pre>
<p>This is similar to the previous query. First remove leading spaces with <code>sed</code>, then show all content after the first space occurrence with <code>cut</code>. This will reduce the occurrence of false positive matches. With a increasing number of occurrences, the possibility, that the match is a real street name increases.</p>
<p>If you like to use only those street names, which occurs more than ten times you can query like</p>
<pre><code>$ grep 'k=&quot;name&quot;' nrw-streets.osm | cut -d\&quot; -f4 | sort | \
&gt; uniq -c | sort -rn | sed -e 's/^[[:space:]]*//' | \
&gt; awk '$1 &gt; 10 { print $0}' | cut -d' ' -f2- | wc -l
3352</code></pre>
<p>If you need more streets, matching the above requirements, you can take a bigger pbf file. For non German names, just choose an other country.</p>
<p>The query above for Belgium looks like</p>
<pre><code>$ grep 'k=&quot;name&quot;' belgium-streets.osm | cut -d\&quot; -f4 | sort | uniq -c | sort -rn | \ 
&gt; sed -e 's/^[[:space:]]*//' | awk '$1 &gt; 10 { print $0}' | cut -d' ' -f2- | wc -l
1778</code></pre>
<p>The top 20 streets for Belgium are</p>
<pre><code>$ grep 'k=&quot;name&quot;' belgium-streets.osm | cut -d\&quot; -f4 | sort | uniq -c | sort -rn | \
&gt; sed -e 's/^[[:space:]]*//' | awk '$1 &gt; 10 { print $0}' | cut -d' ' -f2- | head -n 20
Kerkstraat
Molenstraat
Nieuwstraat
Schoolstraat
Stationsstraat
Kapelstraat
Veldstraat
Groenstraat
Kasteelstraat
Kloosterstraat
Broekstraat
Bosstraat
Rue du Moulin
Dorpsstraat
Rue de l&amp;apos;Église
Berkenlaan
Beukenlaan
Bergstraat
Lindestraat
Hoogstraat</code></pre>
<p>Looks slightly different, right?</p>
<p>With these flat files you can generate a combination of streets, cities and postal codes. For the postal codes, a random number generator should fit my needs. This will also work for street numbers. With different pbf country files, I can generate localized address test data.</p>

        </div>
        <div id="footer"> 
            created by Jan Frederik Hake | 
            <a href="https://enter-haken.github.io/atom.xml">atom feed</a> | 
            generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> | 
            <a href="https://github.com/enter-haken/blog">blog source</a> |
            the source code on this site is covered by a <a href="../license.html">MIT license</a> | 
            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Lizenzvertrag" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
        </div>
    </body>
</html>
